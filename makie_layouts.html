<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Jose Storopoli" />
  <meta name="author" content="Rik Huijzer" />
  <meta name="author" content="Lazaro Alonso" />
  <title>布局 - Julia Data Science</title>
  <link rel="shortcut icon" type="image/png" href="/JuliaDataScience/favicon.png"/>
  <link rel="stylesheet" href="/JuliaDataScience/style.css"/>
    <script src="/mousetrap.min.js"></script>
    <!-- TODO: Add url_prefix. -->
  <style>
  @font-face {
    font-family: JuliaMono-Regular;
    src: url("/JuliaMono-Regular.woff2");
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <link rel="stylesheet" href="/JuliaDataScience/github.min.css">
<script src="/JuliaDataScience/highlight.min.js"></script>
<script src="/JuliaDataScience/julia.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('pre').forEach((el) => {
        hljs.highlightElement(el);
    });
});
</script>
 
</head>
<body>
<script>
function click_next() {
  var next = document.getElementById('nav-next');
  next.firstElementChild.nextElementSibling.click();
}
function click_prev() {
  var prev = document.getElementById('nav-prev');
  prev.firstElementChild.click();
}
Mousetrap.bind('right', click_next);
Mousetrap.bind('h', click_prev);
Mousetrap.bind('left', click_prev);
Mousetrap.bind('l', click_next);
</script>

<div class="books-container">
<aside class="books-menu">
<input type="checkbox" id="menu">
<label for="menu">☰</label>
<div class="books-title">
<a href="/JuliaDataScience/">Julia Data Science</a>
</div><br />
<span class="books-subtitle">

</span>
<div class="books-menu-content">
<li><a class="menu-level-1" href="/JuliaDataScience/preface"><b>1</b> Preface</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/why_data_science"><b>1.1</b> What is Data Science?</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/engineering"><b>1.2</b> Software Engineering</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/acknowledgements"><b>1.3</b> Acknowledgements</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/why_julia"><b>2</b> Why Julia?</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/non-programmers"><b>2.1</b> For Non-Programmers</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/programmers"><b>2.2</b> For Programmers</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/julia_accomplish"><b>2.3</b> What Julia Aims to Accomplish?</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/julia_wild"><b>2.4</b> Julia in the Wild</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/julia_basics"><b>3</b> Julia Basics</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/ide"><b>3.1</b> Development Environments</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/syntax"><b>3.2</b> Language Syntax</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/data_structures"><b>3.3</b> Native Data Structures</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/filesystem"><b>3.4</b> Filesystem</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/standardlibrary"><b>3.5</b> Julia Standard Library</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/dataframes"><b>4</b> DataFrames.jl</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/load_save"><b>4.1</b> 加载和保存文件</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/index-and-summarize"><b>4.2</b> Index and Summarize</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/filter_subset"><b>4.3</b> Filter and Subset</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/select"><b>4.4</b> Select</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/missing_data"><b>4.5</b> Types and Missing Data</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/join"><b>4.6</b> Join</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/variable-transformations"><b>4.7</b> Variable Transformations</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/groupby_combine"><b>4.8</b> Groupby 和 Combine</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/df_performance"><b>4.9</b> Performance</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/DataVisualizationMakie"><b>5</b> 使用 Makie.jl 做数据可视化</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/cairomakie"><b>5.1</b> CairoMakie.jl</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/datavisMakie_attributes"><b>5.2</b> 属性</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/themes"><b>5.3</b> 主题</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/使用-latexstrings.jl"><b>5.4</b> 使用 LaTeXStrings.jl</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/makie_colors"><b>5.5</b> 颜色和颜色图（Colormap）</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/makie_layouts"><b>5.6</b> 布局</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/appendix"><b>6</b> Appendix</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/appendix_pkg"><b>6.1</b> Packages Versions</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/notation"><b>6.2</b> Notation</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/references"><b></b> References</a></li>
</div>
</aside>

<div class="books-content">
<h2 data-number="5.6" id="sec:makie_layouts"><span class="header-section-number">5.6</span> 布局</h2>
<p>一个完整的 <strong>画布/布局</strong> 是由 <code>Figure</code> 定义的，创建后将在其中填充各种内容。 下面将以一个包含 <code>Axis</code>，<code>Legend</code> 和 <code>Colorbar</code> 的简单例子开始。 在这项任务中， 就像 <code>Array</code>/<code>Matrix</code> 那样，可以使用 <code>rows</code> 和 <code>columns</code> 索引 <code>Figure</code>。 <code>Axis</code> 位于 <strong>第 1 行，第 1 列</strong>， 即为 <code>fig[1, 1]</code>。 <code>Colorbar</code> 位于 <strong>第 1 行，第 2 列</strong>， 即为 <code>fig[1, 2]</code>。 另外， <code>Legend</code> 位于 <strong>第 2 行</strong> 和 <strong>第 1 - 2 列</strong>， 即为 <code>fig[2, 1:2]</code>。</p>
<pre class="language-julia"><code>function first_layout()
    seed!(123)
    x, y, z = randn(6), randn(6), randn(6)
    fig = Figure(resolution=(600, 400), backgroundcolor=:grey90)
    ax = Axis(fig[1, 1], backgroundcolor=:white)
    pltobj = scatter!(ax, x, y; color=z, label=&quot;scatters&quot;)
    lines!(ax, x, 1.1y; label=&quot;line&quot;)
    Legend(fig[2, 1:2], ax, &quot;labels&quot;, orientation=:horizontal)
    Colorbar(fig[1, 2], pltobj, label=&quot;colorbar&quot;)
    fig
end
first_layout()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_first_layout_.svg" id="fig:first_layout" style="width:60.0%" alt="Figure 27: First Layout." /><figcaption aria-hidden="true">Figure 27: First Layout.</figcaption>
</figure>
<p>这看起来已经不错了，但能变得更好。可以使用以下关键字和方法来解决图的间距问题：</p>
<ul>
<li><code>figure_padding=(left, right, bottom, top)</code></li>
<li><code>padding=(left, right, bottom, top)</code></li>
</ul>
<p>改变 <code>Legend</code> 或 <code>Colorbar</code> 实际大小的方法为：</p>
<blockquote>
<ul>
<li><code>tellheight=true</code> or <code>false</code></li>
<li><code>tellwidth=true</code> or <code>false</code></li>
</ul>
<p><strong>将这些设置为 <code>true</code> 后则需考虑 <code>Legend</code> 或 <code>Colorbar</code> 的实际大小（高或宽）。</strong> 然后这些内容将会相应地调整大小。</p>
</blockquote>
<p>可以使用以下方法指定行和列的间距：</p>
<blockquote>
<ul>
<li><code>colgap!(fig.layout, col, separation)</code></li>
<li><code>rowgap!(fig.layout, row, separation)</code></li>
</ul>
<p><strong>列间距</strong> （<code>colgap!</code>），如果给定了 <code>col</code>，那么间距将只应用在指定的列。 <strong>行间距</strong> （<code>rowgap!</code>），如果给定了 <code>row</code>，那么间距将只应用在指定的行。</p>
</blockquote>
<p>接下来将学习如何将内容放进 <strong>突出部分（protrusion）</strong>，即为 <strong>标题 <code>x</code> 和 <code>y</code>，或 <code>ticks</code> 以及 <code>label</code></strong> 保留的空间。 实现方法是将位置索引改为 <code>fig[i, j, protrusion]</code>， 其中 <em><code>protrusion</code></em> 可以是 <code>Left()</code>， <code>Right()</code>，<code>Bottom()</code> 和 <code>Top()</code>，或者是四个角 <code>TopLeft()</code>， <code>TopRight()</code>， <code>BottomRight()</code>，<code>BottomLeft()</code>。 这些选项将在如下的例子中使用：</p>
<pre class="language-julia"><code>function first_layout_fixed()
    seed!(123)
    x, y, z = randn(6), randn(6), randn(6)
    fig = Figure(figure_padding=(0, 3, 5, 2), resolution=(600, 400),
        backgroundcolor=:grey90, font=&quot;CMU Serif&quot;)
    ax = Axis(fig[1, 1], xlabel=L&quot;x&quot;, ylabel=L&quot;y&quot;,
        title=&quot;Layout example&quot;, backgroundcolor=:white)
    pltobj = scatter!(ax, x, y; color=z, label=&quot;scatters&quot;)
    lines!(ax, x, 1.1y, label=&quot;line&quot;)
    Legend(fig[2, 1:2], ax, &quot;Labels&quot;, orientation=:horizontal,
        tellheight=true, titleposition=:left)
    Colorbar(fig[1, 2], pltobj, label=&quot;colorbar&quot;)
    # additional aesthetics
    Box(fig[1, 1, Right()], color=(:slateblue1, 0.35))
    Label(fig[1, 1, Right()], &quot;protrusion&quot;, textsize=18,
        rotation=pi / 2, padding=(3, 3, 3, 3))
    Label(fig[1, 1, TopLeft()], &quot;(a)&quot;, textsize=18, padding=(0, 3, 8, 0))
    colgap!(fig.layout, 5)
    rowgap!(fig.layout, 5)
    fig
end
first_layout_fixed()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_first_layout_fixed_.svg" id="fig:first_layout_fixed" style="width:60.0%" alt="Figure 28: First Layout Fixed." /><figcaption aria-hidden="true">Figure 28: First Layout Fixed.</figcaption>
</figure>
<p>这里在 <code>TopLeft()</code>添加标签 <code>(a)</code> 可能是不必要的， 因为标签仅在有两个以上的图时有意义。 在接下来的例子中，我们将继续使用之前的工具和一些新工具，并创建一个更丰富、更复杂的图。</p>
<p>可以使用以下函数隐藏图的装饰部分和轴线：</p>
<blockquote>
<ul>
<li><code>hidedecorations!(ax; kwargs...)</code></li>
<li><code>hidexdecorations!(ax; kwargs...)</code></li>
<li><code>hideydecorations!(ax; kwargs...)</code></li>
<li><code>hidespines!(ax; kwargs...)</code></li>
</ul>
</blockquote>
<p>应记住总是可以调用 <code>help</code> 查看能够传递的参数，例如：</p>
<pre class="language-julia"><code>help(hidespines!)</code></pre>
<pre class="output"><code>  hidespines!(la::Axis, spines::Symbol... = (:l, :r, :b, :t)...)

  Hide all specified axis spines. Hides all spines by default, otherwise
  choose with the symbols :l, :r, :b and :t.

  hidespines! has the following function signatures:

    (Vector, Vector)
    (Vector, Vector, Vector)
    (Matrix)

  Available attributes for Combined{Makie.MakieLayout.hidespines!, T} where T
  are:

  </code></pre>
<p>另外，对于 <code>hidedecorations!</code> 有：</p>
<pre class="language-julia"><code>help(hidedecorations!)</code></pre>
<pre class="output"><code>  hidedecorations!(la::Axis)

  Hide decorations of both x and y-axis: label, ticklabels, ticks and grid.

  hidedecorations! has the following function signatures:

    (Vector, Vector)
    (Vector, Vector, Vector)
    (Matrix)

  Available attributes for Combined{Makie.MakieLayout.hidedecorations!, T}
  where T are:

  </code></pre>
<p>对于 <strong>不想隐藏的</strong> 元素，仅需要将它们的值设置为 <code>false</code>，即 <code>hideydecorations!(ax; ticks=false, grid=false)</code>。</p>
<p>同步 <code>Axis</code> 的方式如下：</p>
<blockquote>
<ul>
<li><code>linkaxes!</code>， <code>linkyaxes!</code> 和 <code>linkxaxes!</code></li>
</ul>
<p>这在需要共享轴时会变得很有用。 另一种获得共享轴的方法是设置 <code>limits!</code>。</p>
</blockquote>
<p>使用以下方式可一次性设定<code>limits</code>，当然也能单独为每个方向的轴单独设定：</p>
<blockquote>
<ul>
<li><code>limits!(ax; l, r, b, t)</code>，其中 <code>l</code> 为左侧, <code>r</code> 右侧，<code>b</code> 底部， 和 <code>t</code> 顶部。</li>
</ul>
<p>还能使用 <code>ylims!(low, high)</code> 或 <code>xlims!(low, high)</code>，甚至可以通过 <code>ylims!(low=0)</code> 或 <code>xlims!(high=1)</code> 只设定一边。</p>
</blockquote>
<p>例子如下：</p>
<pre class="language-julia"><code>function complex_layout_double_axis()
    seed!(123)
    x = LinRange(0, 1, 10)
    y = LinRange(0, 1, 10)
    z = rand(10, 10)
    fig = Figure(resolution=(600, 400), font=&quot;CMU Serif&quot;, backgroundcolor=:grey90)
    ax1 = Axis(fig, xlabel=L&quot;x&quot;, ylabel=L&quot;y&quot;)
    ax2 = Axis(fig, xlabel=L&quot;x&quot;)
    heatmap!(ax1, x, y, z; colorrange=(0, 1))
    series!(ax2, abs.(z[1:4, :]); labels=[&quot;lab $i&quot; for i = 1:4], color=:Set1_4)
    hm = scatter!(10x, y; color=z[1, :], label=&quot;dots&quot;, colorrange=(0, 1))
    hideydecorations!(ax2, ticks=false, grid=false)
    linkyaxes!(ax1, ax2)
    #layout
    fig[1, 1] = ax1
    fig[1, 2] = ax2
    Label(fig[1, 1, TopLeft()], &quot;(a)&quot;, textsize=18, padding=(0, 6, 8, 0))
    Label(fig[1, 2, TopLeft()], &quot;(b)&quot;, textsize=18, padding=(0, 6, 8, 0))
    Colorbar(fig[2, 1:2], hm, label=&quot;colorbar&quot;, vertical=false, flipaxis=false)
    Legend(fig[1, 3], ax2, &quot;Legend&quot;)
    colgap!(fig.layout, 5)
    rowgap!(fig.layout, 5)
    fig
end
complex_layout_double_axis()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_complex_layout_double_axis_.svg" id="fig:complex_layout_double_axis" style="width:60.0%" alt="Figure 29: Complex layout double axis." /><figcaption aria-hidden="true">Figure 29: Complex layout double axis.</figcaption>
</figure>
<p>如上所示， <code>Colorbar</code> 的方向已经变为水平且它的标签也处在其下方。 这是因为设定了 <code>vertical=false</code> 和 <code>flipaxis=false</code>。 另外，也可以将更多的 <code>Axis</code> 添加到 <code>fig</code> 里，甚至可以是 <code>Colorbar</code> 和 <code>Legend</code>，然后再构建布局。</p>
<p>另一种常见布局是热力图组成的正方网格：</p>
<pre class="language-julia"><code>function squares_layout()
    seed!(123)
    letters = reshape(collect(&#39;a&#39;:&#39;d&#39;), (2, 2))
    fig = Figure(resolution=(600, 400), fontsize=14, font=&quot;CMU Serif&quot;,
        backgroundcolor=:grey90)
    axs = [Axis(fig[i, j], aspect=DataAspect()) for i = 1:2, j = 1:2]
    hms = [heatmap!(axs[i, j], randn(10, 10), colorrange=(-2, 2))
           for i = 1:2, j = 1:2]
    Colorbar(fig[1:2, 3], hms[1], label=&quot;colorbar&quot;)
    [Label(fig[i, j, TopLeft()], &quot;($(letters[i, j]))&quot;, textsize=16,
        padding=(-2, 0, -20, 0)) for i = 1:2, j = 1:2]
    colgap!(fig.layout, 5)
    rowgap!(fig.layout, 5)
    fig
end
squares_layout()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_squares_layout_.svg" id="fig:squares_layout" style="width:60.0%" alt="Figure 30: Squares layout." /><figcaption aria-hidden="true">Figure 30: Squares layout.</figcaption>
</figure>
<p>上图中每一个标签都位于 <strong>突出部分</strong> 并且每一个 <code>Axis</code> 都有 <code>AspectData()</code> 率属性。 图中 <code>Colorbar</code> 位于第三列，并从第一行跨到第二行。</p>
<p>下例将使用称为 <code>Mixed()</code> 的<strong>对齐模式</strong>，这在处理 <code>Axis</code> 间的大量空白区域时很有用，而这些空白区域通常是由长标签导致的。 另外，本例还需要使用 Julia 标准库中的 <code>Dates</code> 。</p>
<pre><code>using Dates</code></pre>
<pre class="language-julia"><code>function mixed_mode_layout()
    seed!(123)
    longlabels = [&quot;$(today() - Day(1))&quot;, &quot;$(today())&quot;, &quot;$(today() + Day(1))&quot;]
    fig = Figure(resolution=(600, 400), fontsize=12,
        backgroundcolor=:grey90, font=&quot;CMU Serif&quot;)
    ax1 = Axis(fig[1, 1])
    ax2 = Axis(fig[1, 2], xticklabelrotation=pi / 2, alignmode=Mixed(bottom=0),
        xticks=([1, 5, 10], longlabels))
    ax3 = Axis(fig[2, 1:2])
    ax4 = Axis(fig[3, 1:2])
    axs = [ax1, ax2, ax3, ax4]
    [lines!(ax, 1:10, rand(10)) for ax in axs]
    hidexdecorations!(ax3; ticks=false, grid=false)
    Box(fig[2:3, 1:2, Right()], color=(:slateblue1, 0.35))
    Label(fig[2:3, 1:2, Right()], &quot;protrusion&quot;, rotation=pi / 2, textsize=14,
        padding=(3, 3, 3, 3))
    Label(fig[1, 1:2, Top()], &quot;Mixed alignmode&quot;, textsize=16,
        padding=(0, 0, 15, 0))
    colsize!(fig.layout, 1, Auto(2))
    rowsize!(fig.layout, 2, Auto(0.5))
    rowsize!(fig.layout, 3, Auto(0.5))
    rowgap!(fig.layout, 1, 15)
    rowgap!(fig.layout, 2, 0)
    colgap!(fig.layout, 5)
    fig
end
mixed_mode_layout()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_mixed_mode_layout_.svg" id="fig:mixed_mode_layout" style="width:60.0%" alt="Figure 31: Mixed mode layout." /><figcaption aria-hidden="true">Figure 31: Mixed mode layout.</figcaption>
</figure>
<p>如上，参数 <code>alignmode=Mixed(bottom=0)</code> 将边界框移动到底部，使其与左侧面板保持对齐。</p>
<p>从上图也可以看到 <code>colsize!</code> 和 <code>rowsize!</code> 如何作用于不同的行和列。 可以向函数传递一个数字而不是 <code>Auto()</code>，但那会固定所有的设置。 另外， 在定义 <code>Axis</code> 时也可以设定 <code>height</code> 或 <code>width</code>，例如 <code>Axis(fig, heigth=50)</code> 将会固定轴的高度。</p>
<h3 data-number="5.6.1" id="嵌套-axis-subplots"><span class="header-section-number">5.6.1</span> 嵌套 <code>Axis</code> (<em>subplots</em>)</h3>
<p>精准定义一组 <code>Axis</code> (<em>subplots</em>) 也是可行的， 可以使用一组 <code>Axis</code> 构造具有多行多列的图。 例如，下面展示了一组较复杂的 <code>Axis</code>：</p>
<pre class="language-julia"><code>function nested_sub_plot!(fig)
    color = rand(RGBf0)
    ax1 = Axis(fig[1, 1], backgroundcolor=(color, 0.25))
    ax2 = Axis(fig[1, 2], backgroundcolor=(color, 0.25))
    ax3 = Axis(fig[2, 1:2], backgroundcolor=(color, 0.25))
    ax4 = Axis(fig[1:2, 3], backgroundcolor=(color, 0.25))
    return (ax1, ax2, ax3, ax4)
end</code></pre>
<p>当通过多次调用它来构建更复杂的图时，可以得到：</p>
<pre class="language-julia"><code>function main_figure()
    fig = Figure()
    Axis(fig[1, 1])
    nested_sub_plot!(fig[1, 2])
    nested_sub_plot!(fig[1, 3])
    nested_sub_plot!(fig[2, 1:3])
    fig
end
main_figure()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_main_figure_.svg" id="fig:main_figure" style="width:60.0%" alt="Figure 32: Main figure." /><figcaption aria-hidden="true">Figure 32: Main figure.</figcaption>
</figure>
<p>注意，这里可以调用不同的子图函数。 另外，每一个 <code>Axis</code> 都是 <code>Figure</code> 的独立部分。 因此，当在进行 <code>rowgap!</code>或者 <code>colsize!</code> 这样的操作时，你需要考虑是对每一个子图单独作用还是对所有的图一起作用。</p>
<p>对于组合的 <code>Axis</code> (<em>subplots</em>) 可以使用 <code>GridLayout()</code>， 它能用来构造更复杂的 <code>Figure</code>。</p>
<h3 data-number="5.6.2" id="嵌套网格布局"><span class="header-section-number">5.6.2</span> 嵌套网格布局</h3>
<p>可以使用 <code>GridLayout()</code> 组合子图，这种方法能够更自由地构建更复杂的图。 这里再次使用之前的 <code>nested_sub_plot!</code>，它定义了三组子图和一个普通的 <code>Axis</code>：</p>
<pre class="language-julia"><code>function nested_Grid_Layouts()
    fig = Figure(backgroundcolor=RGBf0(0.96, 0.96, 0.96))
    ga = fig[1, 1] = GridLayout()
    gb = fig[1, 2] = GridLayout()
    gc = fig[1, 3] = GridLayout()
    gd = fig[2, 1:3] = GridLayout()
    gA = Axis(ga[1, 1])
    nested_sub_plot!(gb)
    axsc = nested_sub_plot!(gc)
    nested_sub_plot!(gd)
    [hidedecorations!(axsc[i], grid=false, ticks=false) for i = 1:length(axsc)]
    colgap!(gc, 5)
    rowgap!(gc, 5)
    rowsize!(fig.layout, 2, Auto(0.5))
    colsize!(fig.layout, 1, Auto(0.5))
    fig
end
nested_Grid_Layouts()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_nested_Grid_Layouts_.svg" id="fig:nested_Grid_Layouts" style="width:60.0%" alt="Figure 33: Nested Grid Layouts." /><figcaption aria-hidden="true">Figure 33: Nested Grid Layouts.</figcaption>
</figure>
<p>现在，对每一组使用 <code>rowgap!</code> 或 <code>colsize!</code> 将是可行的，并且 <code>rowsize!, colsize!</code> 也能够应用于 <code>GridLayout()</code>。</p>
<h3 data-number="5.6.3" id="插图"><span class="header-section-number">5.6.3</span> 插图</h3>
<p>目前，绘制 <code>inset</code> 是一项棘手的工作。 本节展示两种在初始时通过定义辅助函数实现绘制插图的方法。 第一种是定义 <code>BBox</code>，它存在于整个 <code>Figure</code> 空间：</p>
<pre class="language-julia"><code>function add_box_inset(fig; left=100, right=250, bottom=200, top=300,
    bgcolor=:grey90)
    inset_box = Axis(fig, bbox=BBox(left, right, bottom, top),
        xticklabelsize=12, yticklabelsize=12, backgroundcolor=bgcolor)
    # bring content upfront
    translate!(inset_box.scene, 0, 0, 10)
    elements = keys(inset_box.elements)
    filtered = filter(ele -&gt; ele != :xaxis &amp;&amp; ele != :yaxis, elements)
    foreach(ele -&gt; translate!(inset_box.elements[ele], 0, 0, 9), filtered)
    return inset_box
end</code></pre>
<p>然后可以按照如下方式轻松地绘制插图：</p>
<pre class="language-julia"><code>function figure_box_inset()
    fig = Figure(resolution=(600, 400))
    ax = Axis(fig[1, 1], backgroundcolor=:white)
    inset_ax1 = add_box_inset(fig; left=100, right=250, bottom=200, top=300,
        bgcolor=:grey90)
    inset_ax2 = add_box_inset(fig; left=500, right=600, bottom=100, top=200,
        bgcolor=(:white, 0.65))
    lines!(ax, 1:10)
    lines!(inset_ax1, 1:10)
    scatter!(inset_ax2, 1:10, color=:black)
    fig
end
figure_box_inset()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_figure_box_inset_.svg" id="fig:figure_box_inset" style="width:60.0%" alt="Figure 34: Figure box inset." /><figcaption aria-hidden="true">Figure 34: Figure box inset.</figcaption>
</figure>
<p>其中 <code>Box</code> 的尺寸受到 <code>Figure</code>中 <code>resolution</code> 参数的约束。 注意，也可以在 <code>Axis</code> 外绘制插图。 另一种绘制插图的方法是，在位置<code>fig[i, j]</code>处定义一个新的 <code>Axis</code>，并且指定 <code>width</code>， <code>height</code>， <code>halign</code> 和 <code>valign</code>。 如下面的函数例子所示：</p>
<pre class="language-julia"><code>function add_axis_inset(; pos=fig[1, 1], halign=0.1, valign=0.5,
    width=Relative(0.5), height=Relative(0.35), bgcolor=:lightgray)
    inset_box = Axis(pos, width=width, height=height,
        halign=halign, valign=valign, xticklabelsize=12, yticklabelsize=12,
        backgroundcolor=bgcolor)
    # bring content upfront
    translate!(inset_box.scene, 0, 0, 10)
    elements = keys(inset_box.elements)
    filtered = filter(ele -&gt; ele != :xaxis &amp;&amp; ele != :yaxis, elements)
    foreach(ele -&gt; translate!(inset_box.elements[ele], 0, 0, 9), filtered)
    return inset_box
end</code></pre>
<p>在下面的例子中，如果总图的大小发生变化，那么将重新缩放灰色背景的 <code>Axis</code>。 同时 <strong>插图</strong> 要受到 <code>Axis</code> 位置的约束。</p>
<pre class="language-julia"><code>function figure_axis_inset()
    fig = Figure(resolution=(600, 400))
    ax = Axis(fig[1, 1], backgroundcolor=:white)
    inset_ax1 = add_axis_inset(; pos=fig[1, 1], halign=0.1, valign=0.65,
        width=Relative(0.3), height=Relative(0.3), bgcolor=:grey90)
    inset_ax2 = add_axis_inset(; pos=fig[1, 1], halign=1, valign=0.25,
        width=Relative(0.25), height=Relative(0.3), bgcolor=(:white, 0.65))
    lines!(ax, 1:10)
    lines!(inset_ax1, 1:10)
    scatter!(inset_ax2, 1:10, color=:black)
    fig
end
figure_axis_inset()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_figure_axis_inset_.svg" id="fig:figure_axis_inset" style="width:60.0%" alt="Figure 35: Figure axis inset." /><figcaption aria-hidden="true">Figure 35: Figure axis inset.</figcaption>
</figure>
<p>以上包含了 Makie 中布局选项的大多数常见用例。 现在，让我们接下来使用 <code>GLMakie.jl</code> 绘制一些漂亮的3D示例图。 ## GLMakie.jl {#sec:glmakie}</p>
<p><code>CairoMakie.jl</code> supplies all our needs for static 2D images. But sometimes we want interactivity, especially when we are dealing with 3D images. Visualizing data in 3D is also a common practice to gain insight from your data. This is where <code>GLMakie.jl</code> might be helpful, since it uses <a href="http://www.opengl.org/">OpenGL</a> as a backend that adds interactivity and responsiveness to plots. Like before, a simple plot includes, of course, lines and points. So, we will start with those and since we already know how layouts work, we will put that into practice.</p>
<h3 data-number="5.6.4" id="scatters-and-lines"><span class="header-section-number">5.6.4</span> Scatters and Lines</h3>
<p>For scatter plots we have two options, the first one is <code>scatter(x, y, z)</code> and the second one is <code>meshscatter(x, y, z)</code>. In the first one markers don’t scale in the axis directions, but in the later they do because they are actual geometries in 3D space. See the next example:</p>
<pre><code>using GLMakie
GLMakie.activate!()</code></pre>
<pre class="language-julia"><code>function scatters_in_3D()
    seed!(123)
    xyz = randn(10, 3)
    x, y, z = xyz[:, 1], xyz[:, 2], xyz[:, 3]
    fig = Figure(resolution=(1600, 400))
    ax1 = Axis3(fig[1, 1]; aspect=(1, 1, 1), perspectiveness=0.5)
    ax2 = Axis3(fig[1, 2]; aspect=(1, 1, 1), perspectiveness=0.5)
    ax3 = Axis3(fig[1, 3]; aspect=:data, perspectiveness=0.5)
    scatter!(ax1, x, y, z; markersize=50)
    meshscatter!(ax2, x, y, z; markersize=0.25)
    hm = meshscatter!(ax3, x, y, z; markersize=0.25,
        marker=FRect3D(Vec3f(0), Vec3f(1)), color=1:size(xyz)[2],
        colormap=:plasma, transparency=false)
    Colorbar(fig[1, 4], hm, label=&quot;values&quot;, height=Relative(0.5))
    fig
end
scatters_in_3D()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_scatters_in_3D_.png" id="fig:scatters_in_3D" alt="Figure 36: Scatters in 3D." /><figcaption aria-hidden="true">Figure 36: Scatters in 3D.</figcaption>
</figure>
<p>Note also, that a different geometry can be passed as markers, i.e., a square/rectangle and we can assign a <code>colormap</code> for them as well. In the middle panel one could get perfect spheres by doing <code>aspect = :data</code> as in the right panel.</p>
<p>And doing <code>lines</code> or <code>scatterlines</code> is also straightforward:</p>
<pre class="language-julia"><code>function lines_in_3D()
    seed!(123)
    xyz = randn(10, 3)
    x, y, z = xyz[:, 1], xyz[:, 2], xyz[:, 3]
    fig = Figure(resolution=(1600, 400))
    ax1 = Axis3(fig[1, 1]; aspect=(1, 1, 1), perspectiveness=0.5)
    ax2 = Axis3(fig[1, 2]; aspect=(1, 1, 1), perspectiveness=0.5)
    ax3 = Axis3(fig[1, 3]; aspect=:data, perspectiveness=0.5)
    lines!(ax1, x, y, z; color=1:size(xyz)[2], linewidth=3)
    scatterlines!(ax2, x, y, z; markersize=50)
    hm = meshscatter!(ax3, x, y, z; markersize=0.2, color=1:size(xyz)[2])
    lines!(ax3, x, y, z; color=1:size(xyz)[2])
    Colorbar(fig[2, 1], hm; label=&quot;values&quot;, height=15, vertical=false,
        flipaxis=false, ticksize=15, tickalign=1, width=Relative(3.55 / 4))
    fig
end
lines_in_3D()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_lines_in_3D_.png" id="fig:lines_in_3D" alt="Figure 37: Lines in 3D." /><figcaption aria-hidden="true">Figure 37: Lines in 3D.</figcaption>
</figure>
<p>Plotting a <code>surface</code> is also easy to do as well as a <code>wireframe</code> and <code>contour</code> lines in 3D.</p>
<h3 data-number="5.6.5" id="surfaces-wireframe-contour-contourf-and-contour3d"><span class="header-section-number">5.6.5</span> Surfaces, wireframe, contour, contourf and contour3d</h3>
<p>To show these cases we’ll use the following <code>peaks</code> function:</p>
<pre class="language-julia"><code>function peaks(; n=49)
    x = LinRange(-3, 3, n)
    y = LinRange(-3, 3, n)
    a = 3 * (1 .- x&#39;) .^ 2 .* exp.(-(x&#39; .^ 2) .- (y .+ 1) .^ 2)
    b = 10 * (x&#39; / 5 .- x&#39; .^ 3 .- y .^ 5) .* exp.(-x&#39; .^ 2 .- y .^ 2)
    c = 1 / 3 * exp.(-(x&#39; .+ 1) .^ 2 .- y .^ 2)
    return (x, y, a .- b .- c)
end</code></pre>
<p>The output for the different plotting functions is</p>
<pre class="language-julia"><code>function plot_peaks_function()
    x, y, z = peaks()
    x2, y2, z2 = peaks(; n=15)
    fig = Figure(resolution=(1600, 400), fontsize=26)
    axs = [Axis3(fig[1, i]; aspect=(1, 1, 1)) for i = 1:3]
    hm = surface!(axs[1], x, y, z)
    wireframe!(axs[2], x2, y2, z2)
    contour3d!(axs[3], x, y, z; levels=20)
    Colorbar(fig[1, 4], hm, height=Relative(0.5))
    fig
end
plot_peaks_function()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_plot_peaks_function_.png" id="fig:plot_peaks_function" alt="Figure 38: Plot peaks function." /><figcaption aria-hidden="true">Figure 38: Plot peaks function.</figcaption>
</figure>
<p>But, it can also be plotted with a <code>heatmap(x, y, z)</code>, <code>contour(x, y, z)</code> or <code>contourf(x, y, z)</code>:</p>
<pre class="language-julia"><code>function heatmap_contour_and_contourf()
    x, y, z = peaks()
    fig = Figure(resolution=(1600, 400), fontsize=26)
    axs = [Axis(fig[1, i]; aspect=DataAspect()) for i = 1:3]
    hm = heatmap!(axs[1], x, y, z)
    contour!(axs[2], x, y, z; levels=20)
    contourf!(axs[3], x, y, z)
    Colorbar(fig[1, 4], hm, height=Relative(0.5))
    fig
end
heatmap_contour_and_contourf()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_heatmap_contour_and_contourf_.png" id="fig:heatmap_contour_and_contourf" alt="Figure 39: Heatmap contour and contourf." /><figcaption aria-hidden="true">Figure 39: Heatmap contour and contourf.</figcaption>
</figure>
<p>Additionally, by changing <code>Axis</code> to an <code>Axis3</code>, these plots will be automatically be in the x-y plane:</p>
<pre class="language-julia"><code>function heatmap_contour_and_contourf_in_a_3d_plane()
    x, y, z = peaks()
    fig = Figure(resolution=(1600, 400), fontsize=26)
    axs = [Axis3(fig[1, i]) for i = 1:3]
    hm = heatmap!(axs[1], x, y, z)
    contour!(axs[2], x, y, z; levels=20)
    contourf!(axs[3], x, y, z)
    Colorbar(fig[1, 4], hm, height=Relative(0.5))
    fig
end
heatmap_contour_and_contourf_in_a_3d_plane()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_heatmap_contour_and_contourf_in_a_3d_plane_.png" id="fig:heatmap_contour_and_contourf_in_a_3d_plane" alt="Figure 40: Heatmap contour and contourf in a 3d plane." /><figcaption aria-hidden="true">Figure 40: Heatmap contour and contourf in a 3d plane.</figcaption>
</figure>
<p>Something else that is easy to do is to mix all these plotting functions into just one plot, namely:</p>
<pre><code>using TestImages</code></pre>
<pre class="language-julia"><code>function mixing_surface_contour3d_contour_and_contourf()
    img = testimage(&quot;coffee.png&quot;)
    x, y, z = peaks()
    cmap = :Spectral_11
    fig = Figure(resolution=(1200, 800), fontsize=26)
    ax1 = Axis3(fig[1, 1]; aspect=(1, 1, 1), elevation=pi / 6, xzpanelcolor=(:black, 0.75),
        perspectiveness=0.5, yzpanelcolor=:black, zgridcolor=:grey70,
        ygridcolor=:grey70, xgridcolor=:grey70)
    ax2 = Axis3(fig[1, 3]; aspect=(1, 1, 1), elevation=pi / 6, perspectiveness=0.5)
    hm = surface!(ax1, x, y, z; colormap=(cmap, 0.95), shading=true)
    contour3d!(ax1, x, y, z .+ 0.02; colormap=cmap, levels=20, linewidth=2)
    xmin, ymin, zmin = minimum(ax1.finallimits[])
    xmax, ymax, zmax = maximum(ax1.finallimits[])
    contour!(ax1, x, y, z; colormap=cmap, levels=20, transformation=(:xy, zmax))
    contourf!(ax1, x, y, z; colormap=cmap, transformation=(:xy, zmin))
    Colorbar(fig[1, 2], hm, width=15, ticksize=15, tickalign=1, height=Relative(0.35))
    # transformations into planes
    heatmap!(ax2, x, y, z; colormap=:viridis, transformation=(:yz, 3.5))
    contourf!(ax2, x, y, z; colormap=:CMRmap, transformation=(:xy, -3.5))
    contourf!(ax2, x, y, z; colormap=:bone_1, transformation=(:xz, 3.5))
    image!(ax2, -3 .. 3, -3 .. 2, rotr90(img); transformation=(:xy, 3.8))
    xlims!(ax2, -3.8, 3.8)
    ylims!(ax2, -3.8, 3.8)
    zlims!(ax2, -3.8, 3.8)
    fig
end
mixing_surface_contour3d_contour_and_contourf()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_mixing_surface_contour3d_contour_and_contourf_.png" id="fig:mixing_surface_contour3d_contour_and_contourf" style="width:60.0%" alt="Figure 41: Mixing surface, contour3d, contour and contourf." /><figcaption aria-hidden="true">Figure 41: Mixing surface, contour3d, contour and contourf.</figcaption>
</figure>
<p>Not bad, right? From there is clear that any <code>heatmap</code>’s, <code>contour</code>’s, <code>contourf</code>’s or <code>image</code> can be plotted into any plane.</p>
<h3 data-number="5.6.6" id="arrows-and-streamplots"><span class="header-section-number">5.6.6</span> Arrows and Streamplots</h3>
<p><code>arrows</code> and <code>streamplot</code> are plots that might be useful when we want to know the directions that a given variable will follow. See a demonstration below<a href="/JuliaDataScience#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a>:</p>
<pre><code>using LinearAlgebra</code></pre>
<pre class="language-julia"><code>function arrows_and_streamplot_in_3d()
    ps = [Point3f(x, y, z) for x = -3:1:3 for y = -3:1:3 for z = -3:1:3]
    ns = map(p -&gt; 0.1 * rand() * Vec3f(p[2], p[3], p[1]), ps)
    lengths = norm.(ns)
    flowField(x, y, z) = Point(-y + x * (-1 + x^2 + y^2)^2, x + y * (-1 + x^2 + y^2)^2,
        z + x * (y - z^2))
    fig = Figure(resolution=(1200, 800), fontsize=26)
    axs = [Axis3(fig[1, i]; aspect=(1, 1, 1), perspectiveness=0.5) for i = 1:2]
    arrows!(axs[1], ps, ns, color=lengths, arrowsize=Vec3f0(0.2, 0.2, 0.3),
        linewidth=0.1)
    streamplot!(axs[2], flowField, -4 .. 4, -4 .. 4, -4 .. 4, colormap=:plasma,
        gridsize=(7, 7), arrow_size=0.25, linewidth=1)
    fig
end
arrows_and_streamplot_in_3d()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_arrows_and_streamplot_in_3d_.png" id="fig:arrows_and_streamplot_in_3d" style="width:60.0%" alt="Figure 42: Arrows and streamplot in 3d." /><figcaption aria-hidden="true">Figure 42: Arrows and streamplot in 3d.</figcaption>
</figure>
<p>Other interesting examples are a <code>mesh(obj)</code>, a <code>volume(x, y, z, vals)</code>, and a <code>contour(x, y, z, vals)</code>.</p>
<h3 data-number="5.6.7" id="meshes-and-volumes"><span class="header-section-number">5.6.7</span> Meshes and Volumes</h3>
<p>Drawing Meshes comes in handy when you want to plot geometries, like a <code>Sphere</code> or a Rectangle, i. e. <code>FRect3D</code>. Another approach to visualize points in 3D space is by calling the functions <code>volume</code> and <code>contour</code>, which implements <a href="https://en.wikipedia.org/wiki/Ray_tracing_(graphics)">ray tracing</a> to simulate a wide variety of optical effects. See the next examples:</p>
<pre><code>using GeometryBasics</code></pre>
<pre class="language-julia"><code>function mesh_volume_contour()
    # mesh objects
    rectMesh = FRect3D(Vec3f(-0.5), Vec3f(1))
    recmesh = GeometryBasics.mesh(rectMesh)
    sphere = Sphere(Point3f(0), 1)
    # https://juliageometry.github.io/GeometryBasics.jl/stable/primitives/
    spheremesh = GeometryBasics.mesh(Tesselation(sphere, 64))
    # uses 64 for tesselation, a smoother sphere
    colors = [rand() for v in recmesh.position]
    # cloud points for volume
    x = y = z = 1:10
    vals = randn(10, 10, 10)
    fig = Figure(resolution=(1600, 400))
    axs = [Axis3(fig[1, i]; aspect=(1, 1, 1), perspectiveness=0.5) for i = 1:3]
    mesh!(axs[1], recmesh; color=colors, colormap=:rainbow, shading=false)
    mesh!(axs[1], spheremesh; color=(:white, 0.25), transparency=true)
    volume!(axs[2], x, y, z, vals; colormap=Reverse(:plasma))
    contour!(axs[3], x, y, z, vals; colormap=Reverse(:plasma))
    fig
end
mesh_volume_contour()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_mesh_volume_contour_.png" id="fig:mesh_volume_contour" alt="Figure 43: Mesh volume contour." /><figcaption aria-hidden="true">Figure 43: Mesh volume contour.</figcaption>
</figure>
<p>Note that here we are plotting two meshes in the same axis, one transparent sphere and a cube. So far, we have covered most of the 3D use-cases. Another example is <code>?linesegments</code>.</p>
<p>Taking as reference the previous example one can do the following custom plot with spheres and rectangles:</p>
<pre><code>using GeometryBasics, Colors</code></pre>
<p>For the spheres let’s do a rectangular grid. Also, we will use a different color for each one of them. Additionally, we can mix spheres and a rectangular plane. Next, we define all the necessary data.</p>
<pre class="language-julia"><code>seed!(123)
spheresGrid = [Point3f(i,j,k) for i in 1:2:10 for j in 1:2:10 for k in 1:2:10]
colorSphere = [RGBA(i * 0.1, j * 0.1, k * 0.1, 0.75) for i in 1:2:10 for j in 1:2:10 for k in 1:2:10]
spheresPlane = [Point3f(i,j,k) for i in 1:2.5:20 for j in 1:2.5:10 for k in 1:2.5:4]
cmap = get(colorschemes[:plasma], LinRange(0, 1, 50))
colorsPlane = cmap[rand(1:50,50)]
rectMesh = FRect3D(Vec3f(-1, -1, 2.1), Vec3f(22, 11, 0.5))
recmesh = GeometryBasics.mesh(rectMesh)
colors = [RGBA(rand(4)...) for v in recmesh.position]</code></pre>
<p>Then, the plot is simply done with:</p>
<pre class="language-julia"><code>function grid_spheres_and_rectangle_as_plate()
    fig = with_theme(theme_dark()) do
        fig = Figure(resolution=(1200, 800))
        ax1 = Axis3(fig[1, 1]; aspect=:data, perspectiveness=0.5, azimuth=0.72)
        ax2 = Axis3(fig[1, 2]; aspect=:data, perspectiveness=0.5)
        meshscatter!(ax1, spheresGrid; color = colorSphere, markersize = 1,
            shading=false)
        meshscatter!(ax2, spheresPlane; color=colorsPlane, markersize = 0.75,
            lightposition=Vec3f(10, 5, 2), ambient=Vec3f(0.95, 0.95, 0.95),
            backlight=1.0f0)
        mesh!(recmesh; color=colors, colormap=:rainbow, shading=false)
        limits!(ax1, 0, 10, 0, 10, 0, 10)
        fig
    end
    fig
end
grid_spheres_and_rectangle_as_plate()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_grid_spheres_and_rectangle_as_plate_.png" id="fig:grid_spheres_and_rectangle_as_plate" style="width:60.0%" alt="Figure 44: Grid spheres and rectangle as plate." /><figcaption aria-hidden="true">Figure 44: Grid spheres and rectangle as plate.</figcaption>
</figure>
<p>Here, the rectangle is semi-transparent due to the alpha channel added to the RGB color. The rectangle function is quite versatile, for instance 3D boxes are easy do implement which in turn could be used for plotting a 3D histogram. See our next example, where we are using again our <code>peaks</code> function and some additional definitions:</p>
<pre class="language-julia"><code>x, y, z = peaks(; n=15)
δx = (x[2] - x[1]) / 2
δy = (y[2] - y[1]) / 2
cbarPal = :Spectral_11
ztmp = (z .- minimum(z)) ./ (maximum(z .- minimum(z)))
cmap = get(colorschemes[cbarPal], ztmp)
cmap2 = reshape(cmap, size(z))
ztmp2 = abs.(z) ./ maximum(abs.(z)) .+ 0.15</code></pre>
<p>here <span class="math inline">\(\delta x, \delta y\)</span> are used to specified our boxes size. <code>cmap2</code> will be the color for each box and <code>ztmp2</code> will be used as a transparency parameter. See the output in the next figure.</p>
<pre class="language-julia"><code>function histogram_or_bars_in_3d()
    fig = Figure(resolution=(1200, 800), fontsize=26)
    ax1 = Axis3(fig[1, 1]; aspect=(1, 1, 1), elevation=π/6,
        perspectiveness=0.5)
    ax2 = Axis3(fig[1, 2]; aspect=(1, 1, 1), perspectiveness=0.5)
    rectMesh = FRect3D(Vec3f0(-0.5, -0.5, 0), Vec3f0(1, 1, 1))
    meshscatter!(ax1, x, y, 0*z, marker = rectMesh, color = z[:],
        markersize = Vec3f.(2δx, 2δy, z[:]), colormap = :Spectral_11,
        shading=false)
    limits!(ax1, -3.5, 3.5, -3.5, 3.5, -7.45, 7.45)
    meshscatter!(ax2, x, y, 0*z, marker = rectMesh, color = z[:],
        markersize = Vec3f.(2δx, 2δy, z[:]), colormap = (:Spectral_11, 0.25),
        shading=false, transparency=true)
    for (idx, i) in enumerate(x), (idy, j) in enumerate(y)
        rectMesh = FRect3D(Vec3f(i - δx, j - δy, 0), Vec3f(2δx, 2δy, z[idx, idy]))
        recmesh = GeometryBasics.mesh(rectMesh)
        lines!(ax2, recmesh; color=(cmap2[idx, idy], ztmp2[idx, idy]))
    end
    fig
end
histogram_or_bars_in_3d()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_histogram_or_bars_in_3d_.png" id="fig:histogram_or_bars_in_3d" style="width:60.0%" alt="Figure 45: Histogram or bars in 3d." /><figcaption aria-hidden="true">Figure 45: Histogram or bars in 3d.</figcaption>
</figure>
<p>Note, that you can also call <code>lines</code> or <code>wireframe</code> over a mesh object.</p>
<h3 data-number="5.6.8" id="filled-line-and-band"><span class="header-section-number">5.6.8</span> Filled Line and Band</h3>
<p>For our last example we will show how to do a filled curve in 3D with <code>band</code> and some <code>linesegments</code>:</p>
<pre class="language-julia"><code>function filled_line_and_linesegments_in_3D()
    xs = LinRange(-3, 3, 10)
    lower = [Point3f(i, -i, 0) for i in LinRange(0, 3, 100)]
    upper = [Point3f(i, -i, sin(i) * exp(-(i + i))) for i in range(0, 3, length=100)]
    fig = Figure(resolution=(1200, 800))
    axs = [Axis3(fig[1, i]; elevation=pi/6, perspectiveness=0.5) for i = 1:2]
    band!(axs[1], lower, upper, color=repeat(norm.(upper), outer=2), colormap=:CMRmap)
    lines!(axs[1], upper, color=:black)
    linesegments!(axs[2], cos.(xs), xs, sin.(xs), linewidth=5, color=1:length(xs))
    fig
end
filled_line_and_linesegments_in_3D()</code></pre>
<figure>
<img src="/JuliaDataScience/im/JDS_filled_line_and_linesegments_in_3D_.png" id="fig:filled_line_and_linesegments_in_3D" style="width:60.0%" alt="Figure 46: Filled line and linesegments in 3D." /><figcaption aria-hidden="true">Figure 46: Filled line and linesegments in 3D.</figcaption>
</figure>
<p>Finally, our journey doing 3D plots has come to an end. You can combine everything we exposed here to create amazing 3D images!</p>


<div class="bottom-nav">
    <p id="nav-prev" style="text-align: left;">
        <a class="menu-level-2" href="/JuliaDataScience/makie_colors"><b>5.5</b> 颜色和颜色图（Colormap）</a> <kbd>←</kbd>
        <span id="nav-next" style="float: right;">
            <kbd>→</kbd> <a class="menu-level-1" href="/JuliaDataScience/appendix"><b>6</b> Appendix</a>
        </span>
    </p>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn18" role="doc-endnote"><p> 18. we are using the <code>LinearAlgebra</code> module from Julia’s standard library.<a href="/JuliaDataScience#fnref18" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>


<div class="license">
    <br/>
  <br/>
  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
    Jose Storopoli, Rik Huijzer, Lazaro Alonso
</div>
</div>
</div>
</body>
</html>